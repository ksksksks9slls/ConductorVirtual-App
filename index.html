<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Orchestra V22 - AR</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; background: #000; overflow: hidden; font-family: 'Inter', sans-serif; }
        .input_video { position: fixed; width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); opacity: 0.15; z-index: 0; filter: brightness(0.4) contrast(1.5) grayscale(0.8); transition: filter 0.3s ease-out; }
        .output_canvas { position: fixed; width: 100%; height: 100%; z-index: 1; transform: scaleX(-1); }
        
        #three-canvas { position: fixed; inset: 0; z-index: 2; transform: scaleX(-1); } /* Canvas para Three.js */

        #ui-layer { position: fixed; inset: 0; z-index: 10; display: flex; flex-direction: column; justify-content: center; align-items: center; background: rgba(0,0,0,0.95); color: white; text-align: center; }
        .panel { background: rgba(0,0,0,0.8); padding: 50px; border-radius: 40px; border: 1px solid rgba(0,255,234,0.3); width: 85%; max-width: 450px; box-shadow: 0 0 80px rgba(0,255,234,0.08); }
        .btn { padding: 20px; background: #00ffea; color: #000; border: none; border-radius: 50px; font-weight: bold; cursor: pointer; width: 100%; text-transform: uppercase; margin-top: 15px; letter-spacing: 2px; transition: all 0.3s ease; }
        .btn:hover { transform: scale(1.03); box-shadow: 0 0 25px rgba(0,255,234,0.5); }
        
        #ver-tag { position: fixed; bottom: 10px; right: 15px; font-size: 0.6em; color: rgba(0,255,234,0.25); z-index: 20; letter-spacing: 2px; }
        #hud { position: fixed; top: 30px; left: 30px; color: #00ffea; font-family: 'Courier New', Courier, monospace; z-index: 5; display: none; font-size: 0.9em; text-shadow: 0 0 8px rgba(0,255,234,0.6); }
        #flash-layer { position: fixed; inset: 0; background: white; opacity: 0; z-index: 100; pointer-events: none; transition: opacity 0.05s ease-out; }

        /* Foco de Escenario - Vignette */
        #vignette {
            position: fixed; inset: 0; z-index: 1;
            box-shadow: 0 0 0 50vw rgba(0,0,0,0.95); /* Gran sombra que simula la oscuridad */
            border-radius: 50%; /* Para hacer el centro claro */
            transform: scale(0.1); /* Empieza muy pequeño */
            filter: blur(50px); /* Suaviza el borde */
            transition: all 0.5s ease-out; /* Transición suave */
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="flash-layer"></div>
    <video class="input_video" playsinline muted></video>
    <div id="vignette"></div>
    <canvas id="three-canvas"></canvas> <canvas class="output_canvas"></canvas> <div id="ver-tag">ORCHESTRA v22.0 AR</div>
    <div id="hud">SECCIÓN: CENTRO | TEMPO: 100% | SALA: TEATRO</div>

    <div id="ui-layer">
        <div id="panel-content" class="panel">
            <h1 style="letter-spacing: 12px; margin: 0; font-weight: 200;">ORCHESTRA</h1>
            <p style="font-size: 0.6em; opacity: 0.5; margin-bottom: 40px; letter-spacing: 3px;">SIMULACIÓN DE REALIDAD AUMENTADA</p>
            
            <div id="actions">
                <input type="file" id="audio-input" accept="audio/*" style="display:none">
                <button class="btn" onclick="document.getElementById('audio-input').click()">SUBIR PARTITURA</button>
                <button class="btn" style="background:transparent; color:#00ffea; border:1px solid #00ffea;" onclick="startFreeMode()">MODO LIBRE</button>
            </div>
            <p id="status-msg" style="font-size: 0.7em; margin-top: 30px; color: #00ffea; opacity: 0.8;">PREPARANDO ESCENARIO...</p>
        </div>
    </div>

    <script type="module"> // Usamos 'module' para importar Three.js fácilmente

        // --- Configuración de Three.js ---
        let scene, camera, renderer, batuta, atril;
        let batutaVisible = false;
        const threeCanvas = document.getElementById('three-canvas');

        function initThree() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ canvas: threeCanvas, alpha: true }); // Alpha true para ver el video detrás
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            // Luz ambiental tenue
            scene.add(new THREE.AmbientLight(0x404040));
            // Luz direccional que puede simular el foco
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(0, 1, 1).normalize();
            scene.add(directionalLight);

            // --- Batuta 3D ---
            const batutaGeometry = new THREE.CylinderGeometry(0.01, 0.005, 0.4, 8); // Cilindro delgado
            const batutaMaterial = new THREE.MeshLambertMaterial({ color: 0xcccccc, emissive: 0x00ffea, emissiveIntensity: 0.1 }); // Blanco con brillo cian
            batuta = new THREE.Mesh(batutaGeometry, batutaMaterial);
            batuta.rotation.x = Math.PI / 2; // Orientarla horizontalmente por defecto
            batuta.position.z = -1; // Detrás de la cámara inicialmente
            scene.add(batuta);

            // --- Atril 3D ---
            const atrilGeometry = new THREE.BoxGeometry(0.5, 0.8, 0.05); // Panel del atril
            const atrilMaterial = new THREE.MeshLambertMaterial({ color: 0x111111, emissive: 0x050505, emissiveIntensity: 0.05 });
            atril = new THREE.Mesh(atrilGeometry, atrilMaterial);
            atril.position.set(0, -0.6, -1.5); // Posición inicial en el "suelo virtual"
            scene.add(atril);

            camera.position.z = 1; // La cámara de Three.js está en el centro

            window.addEventListener('resize', onWindowResize, false);
            animateThree();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animateThree() {
            requestAnimationFrame(animateThree);
            if (batutaVisible) {
                // Hacer brillar la batuta
                batuta.material.emissiveIntensity = 0.5 + Math.sin(Date.now() * 0.005) * 0.4;
            } else {
                batuta.material.emissiveIntensity = 0;
            }
            renderer.render(scene, camera);
        }
        
        // --- Variables globales del simulador ---
        const videoElement = document.querySelector('.input_video');
        const outputCanvas = document.querySelector('.output_canvas');
        const canvasCtx = outputCanvas.getContext('2d');
        const audioInput = document.getElementById('audio-input');
        const flashLayer = document.getElementById('flash-layer');
        const vignetteElement = document.getElementById('vignette');

        let player, reverb, panner, filter, fft;
        let isPlaying = false, isFreeMode = false, flowState = "START";
        let calProgress = 0, golpesDados = 0, lastY = 0, subiendo = false;
        let lerpTempo = 1.0;
        let trail = [], particles = [];

        async function setupEngine(url = null) {
            await Tone.start();
            reverb = new Tone.Reverb({ decay: 5, wet: 0.2 }).toDestination();
            panner = new Tone.Panner(0).connect(reverb);
            filter = new Tone.Filter(20000, "lowpass").connect(panner);
            fft = new Tone.FFT(32);
            filter.connect(fft);

            if(url) {
                player = new Tone.Player(url).connect(filter);
                isFreeMode = false;
            } else {
                isFreeMode = true; isPlaying = true; // En modo libre, empezamos a "tocar" inmediatamente
            }
            
            flowState = "SCANNING";
            document.getElementById('actions').style.display = "none";
            initPose();
        }

        audioInput.onchange = (e) => { if (e.target.files[0]) setupEngine(URL.createObjectURL(e.target.files[0])); };
        function startFreeMode() { setupEngine(); }

        function initPose() {
            const pose = new Pose({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`});
            pose.setOptions({ modelComplexity: 1, smoothLandmarks: true, enableSegmentation: true, minDetectionConfidence: 0.85 }); // Enable segmentation para oclusión
            pose.onResults(onResults);
            new Camera(videoElement, { onFrame: async () => { await pose.send({image: videoElement}); }, width: 1280, height: 720 }).start(); // Mayor resolución para segmentación
        }

        function onResults(results) {
            outputCanvas.width = window.innerWidth;
            outputCanvas.height = window.innerHeight;
            canvasCtx.clearRect(0, 0, outputCanvas.width, outputCanvas.height);

            // 1. Oclusión (Recorte del maestro)
            if (results.segmentationMask) {
                canvasCtx.globalCompositeOperation = 'destination-atop'; // Dibuja la máscara detrás
                canvasCtx.drawImage(results.segmentationMask, 0, 0, outputCanvas.width, outputCanvas.height);
                canvasCtx.globalCompositeOperation = 'source-over'; // Restaurar para el resto de dibujos
            }

            if (results.poseLandmarks) {
                const lm = results.poseLandmarks;
                
                // Mapear coordenadas de MediaPipe a Three.js (0-1 a -1 a 1)
                const convertToThreeCoords = (landmark, zOffset = 0) => {
                    // Invertimos X porque MediaPipe es espejo
                    return new THREE.Vector3(-(landmark.x * 2 - 1), -(landmark.y * 2 - 1), -(landmark.z * 5) + zOffset);
                };

                const wristR = convertToThreeCoords(lm[16]);
                const indexR = convertToThreeCoords(lm[20]);
                const thumbR = convertToThreeCoords(lm[18]); // Pulgar derecho para agarre

                // 2. Control de Batuta 3D por Gesto de "Agarre" (Thumb-Index distance)
                const distanceBetweenThumbAndIndex = Math.hypot(lm[20].x - lm[18].x, lm[20].y - lm[18].y);
                batutaVisible = (distanceBetweenThumbAndIndex < 0.05); // Si pulgar e índice están cerca, la batuta aparece

                if (batutaVisible) {
                    batuta.position.copy(wristR);
                    batuta.lookAt(indexR);
                    batuta.rotation.x += Math.PI / 2; // Ajuste para que el cilindro apunte bien
                } else {
                    batuta.position.z = -100; // Moverla fuera de vista
                }
                
                // 3. Posicionamiento del Atril (Anclaje Virtual)
                const leftFoot = convertToThreeCoords(lm[29]);
                const rightFoot = convertToThreeCoords(lm[30]);
                const avgFootX = (leftFoot.x + rightFoot.x) / 2;
                const avgFootY = (leftFoot.y + rightFoot.y) / 2;
                const avgFootZ = (leftFoot.z + rightFoot.z) / 2;

                atril.position.set(avgFootX, avgFootY + 0.5, avgFootZ - 1); // Posición relativa a los pies
                
                // 4. Foco de Escenario Dinámico (Vignette)
                // Centro del foco en la mano derecha
                vignetteElement.style.left = `${lm[20].x * 100}%`;
                vignetteElement.style.top = `${lm[20].y * 100}%`;
                // El tamaño del foco reacciona a la amplitud de la mano (más movimiento = más luz)
                const handAmplitude = Math.hypot(lm[14].x - lm[16].x, lm[14].y - lm[16].y); // Distancia codo-muñeca
                vignetteElement.style.transform = `scale(${0.1 + (handAmplitude * 2)})`;

                // --- Lógica de Dirección ---
                const handScreenPos = { x: lm[20].x * window.innerWidth, y: lm[20].y * window.innerHeight };
                drawTrail(handScreenPos);
                updateParticles(handScreenPos);

                const speed = Math.abs(lm[20].y - lastY) * 100;

                // 5. SILENCIO DRAMÁTICO (Filtro de video)
                if (speed < 0.05 && isPlaying) {
                    videoElement.style.filter = "brightness(0.05) contrast(1.0) grayscale(1)";
                } else {
                    videoElement.style.filter = "brightness(0.4) contrast(1.5) grayscale(0.8)";
                }

                if (!isPlaying && !isFreeMode && lm[16].y < 0.45) { // Detección de 3 golpes iniciales
                    if (lastY < lm[16].y - 0.1 && !subiendo) {
                        new Tone.MembraneSynth().toDestination().triggerAttackRelease("G2", "16n"); // Sonido de golpe
                        golpesDados++; subiendo = true;
                        if (golpesDados >= 3) { player.start(); isPlaying = true; }
                    }
                    if (lm[16].y < lastY - 0.05) subiendo = false;
                }
                
                // 6. GESTO DE CORTE (Extensión de brazos y pausa)
                // Distancia entre ambas muñecas
                const distHands = Math.hypot(lm[15].x - lm[16].x, lm[15].y - lm[16].y);
                if (isPlaying && distHands > 0.6 && speed < 0.1) { // Manos muy separadas y quietas
                    if (player.state === "started") {
                        player.stop();
                        reverb.wet.value = 1; // Máximo eco para el final
                        setTimeout(() => reverb.wet.value = 0.1, 5000); // Eco se desvanece en 5s
                        isPlaying = false; // Detener la lógica del juego
                        document.getElementById('hud').innerText = "CONCIERTO FINALIZADO";
                    }
                }


                if (isPlaying && !isFreeMode) {
                    // 7. AUDIO 3D (PANNER)
                    let panTarget = (lm[20].x * 2) - 1; 
                    panner.pan.rampTo(-panTarget, 0.3); // Invertido para espejo

                    // 8. INERCIA PROFESIONAL Y REVERB DINÁMICA
                    let targetT = 0.5 + (speed / 7);
                    lerpTempo = (lerpTempo * 0.95) + (Math.min(Math.max(targetT, 0.6), 2.0) * 0.05);
                    player.playbackRate = lerpTempo;

                    let roomWet = Math.max(0.1, (1 - lm[16].y) * 0.7);
                    reverb.wet.rampTo(roomWet, 0.3);

                    // 9. FLASH DE INTENSIDAD
                    if (speed > 4.5) {
                        flashLayer.style.opacity = "0.3";
                        setTimeout(() => flashLayer.style.opacity = "0", 50);
                    }

                    let seccion = panTarget > 0.4 ? "METALES" : (panTarget < -0.4 ? "CUERDAS" : "CENTRO");
                    document.getElementById('hud').innerText = `SECCIÓN: ${seccion} | TEMPO: ${Math.round(lerpTempo * 100)}% | SALA: ${roomWet > 0.4 ? 'GRAN TEATRO' : 'ESTUDIO'}`;
                }
                lastY = lm[20].y;
            }
        }

        function drawTrail(pos) {
            trail.push(pos); if (trail.length > 25) trail.shift();
            canvasCtx.beginPath();
            canvasCtx.lineWidth = 4;
            canvasCtx.lineCap = "round";
            canvasCtx.strokeStyle = "rgba(0, 255, 234, 0.6)";
            for(let i = 0; i < trail.length - 1; i++) {
                canvasCtx.moveTo(trail[i].x, trail[i].y);
                canvasCtx.lineTo(trail[i+1].x, trail[i+1].y);
            }
            canvasCtx.stroke();
            // Ictus Visual
            canvasCtx.fillStyle = "white";
            canvasCtx.beginPath(); canvasCtx.arc(pos.x, pos.y, 6, 0, 7); canvasCtx.fill();
        }

        function updateParticles(hand) {
            if (Math.random() > 0.6) particles.push({ x: hand.x, y: hand.y, vx: (Math.random()-0.5)*8, vy: (Math.random()-0.5)*8, life: 1 });
            particles.forEach((p, i) => {
                p.x += p.vx; p.y += p.vy; p.life -= 0.03;
                canvasCtx.fillStyle = `rgba(0, 255, 234, ${p.life})`;
                canvasCtx.fillRect(p.x, p.y, 2, 2);
                if (p.life <= 0) particles.splice(i, 1);
            });
        }
        
        initThree(); // Inicializar el motor 3D al cargar la página
    </script>
</body>
</html>
